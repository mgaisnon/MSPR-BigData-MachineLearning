import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np
import sys
from pathlib import Path
import logging

# Configuration du logging
logging.getLogger('mysql').setLevel(logging.WARNING)
logging.getLogger('sqlalchemy').setLevel(logging.WARNING)

# Imports des modules
sys.path.append(str(Path(__file__).parent / 'src'))
sys.path.append(str(Path(__file__).parent))

try:
    from src.data_collection.db_collector import ElectionDBCollector
    from src.data_processing.election_processor import ElectionDataProcessor
    from src.models.election_models import ElectionPredictor
except ImportError as e:
    st.error(f"‚ùå Erreur d'import: {e}")
    st.info("üí° V√©rifiez la structure des dossiers src/")
    st.stop()

# Configuration Streamlit
st.set_page_config(
    page_title="üó≥Ô∏è √âlections Occitanie - Analyse & Pr√©dictions",
    page_icon="üó≥Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

@st.cache_data
def load_election_data():
    """Charge les donn√©es depuis VOTRE base MySQL"""
    try:
        # üîß CONNEXION DIRECTE √Ä VOTRE BASE MySQL
        st.info("üîå Connexion √† votre base MySQL...")
        collector = ElectionDBCollector()
        
        # Informations sur votre table
        table_info = collector.get_table_info()
        st.success(f"‚úÖ Connect√© √† la table '{table_info['table_name']}'")
        
        # Chargement des donn√©es
        data = collector.get_election_data()
        
        if data.empty:
            st.error("‚ùå Aucune donn√©e trouv√©e dans votre base pour l'Occitanie")
            st.info("üí° V√©rifiez que votre table contient des donn√©es pour les d√©partements d'Occitanie")
            return pd.DataFrame()
        
        st.success(f"‚úÖ {len(data)} enregistrements charg√©s depuis votre base MySQL")
        
        # Debug info
        with st.expander("üîç Informations sur vos donn√©es"):
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üìä Total enregistrements", len(data))
            with col2:
                st.metric("üèõÔ∏è D√©partements", data['departement'].nunique() if 'departement' in data.columns else 0)
            with col3:
                st.metric("üé≠ Nuances politiques", data['nuance'].nunique() if 'nuance' in data.columns else 0)
            
            st.write("**Structure de votre table:**")
            st.json(table_info)
            
            st.write("**Aper√ßu des donn√©es:**")
            st.dataframe(data.head(10))
        
        collector.close()
        return data
        
    except Exception as e:
        st.error(f"‚ùå Erreur de connexion √† votre base MySQL: {e}")
        st.info("üí° V√©rifications √† faire:")
        st.write("1. MySQL est-il d√©marr√© ?")
        st.write("2. Vos identifiants dans le .env sont-ils corrects ?")
        st.write("3. Votre utilisateur a-t-il les droits sur la base ?")
        st.write("4. La base contient-elle des donn√©es pour l'Occitanie ?")
        
        # Bouton de diagnostic
        if st.button("üîß Lancer le diagnostic"):
            try:
                from config.config import DB_CONFIG
                st.write("**Configuration actuelle:**")
                st.json({
                    "host": DB_CONFIG.host,
                    "database": DB_CONFIG.database,
                    "user": DB_CONFIG.username,
                    "password_configured": bool(DB_CONFIG.password)
                })
            except Exception as diag_error:
                st.error(f"Erreur diagnostic: {diag_error}")
        
        return pd.DataFrame()

def main():
    """Application principale"""
    st.title("üó≥Ô∏è Analyse √âlectorale Occitanie")
    st.markdown("*Analyse et pr√©dictions bas√©es sur votre base MySQL*")
    
    # Sidebar
    st.sidebar.title("üìä Navigation")
    
    # Chargement des donn√©es depuis votre MySQL
    with st.spinner("üîÑ Connexion √† votre base MySQL..."):
        df_raw = load_election_data()
    
    if df_raw.empty:
        st.stop()
    
    # Menu de navigation
    pages = {
        "üìä Tableau de Bord": "dashboard",
        "üîç Analyse Exploratoire": "analysis", 
        "üìà Visualisations": "visualizations",
        "ü§ñ Machine Learning": "ml",
        "üîÆ Pr√©dictions": "predictions",
        "üîç Validation Historique": "validation"
    }
    
    selected_page = st.sidebar.selectbox("Choisissez une section", list(pages.keys()))
    page_key = pages[selected_page]
    
    # Traitement des donn√©es
    try:
        processor = ElectionDataProcessor()
        df_processed = processor.preprocess_election_data(df_raw)
        
        if df_processed.empty:
            st.error("‚ùå Erreur lors du traitement des donn√©es")
            return
        
    except Exception as e:
        st.error(f"‚ùå Erreur traitement donn√©es: {e}")
        st.write("Tentative avec donn√©es brutes...")
        df_processed = df_raw.copy()
    
    # Affichage des pages
    if page_key == "dashboard":
        show_dashboard(df_processed)
    elif page_key == "analysis":
        show_analysis(df_processed)
    elif page_key == "visualizations":
        show_visualizations(df_processed)
    elif page_key == "ml":
        show_ml_results(df_processed, processor)
    elif page_key == "predictions":
        show_predictions(df_processed, processor)
    elif page_key == "validation":
        show_historical_validation(df_processed, processor)

def show_dashboard(df):
    """Tableau de bord avec vos donn√©es MySQL"""
    st.header("üìä Tableau de Bord - Donn√©es de votre Base MySQL")
    
    if df.empty:
        st.warning("Aucune donn√©e √† afficher")
        return
    
    # M√©triques g√©n√©rales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_records = len(df)
        st.metric("üìä Total enregistrements", f"{total_records:,}")
    
    with col2:
        if 'annee' in df.columns:
            annees = df['annee'].nunique()
            st.metric("üìÖ Ann√©es couvertes", annees)
        else:
            st.metric("üìÖ Ann√©es", "N/A")
    
    with col3:
        if 'departement' in df.columns:
            depts = df['departement'].nunique()
            st.metric("üèõÔ∏è D√©partements", depts)
        else:
            st.metric("üèõÔ∏è D√©partements", "N/A")
    
    with col4:
        if 'nuance' in df.columns:
            nuances = df['nuance'].nunique()
            st.metric("üé≠ Nuances politiques", nuances)
        else:
            st.metric("üé≠ Nuances", "N/A")
    
    # Aper√ßu des donn√©es
    st.subheader("üìã Aper√ßu de vos donn√©es")
    st.dataframe(df.head(20), use_container_width=True)
    
    # Distribution par ann√©e si disponible
    if 'annee' in df.columns:
        st.subheader("üìä R√©partition par ann√©e")
        year_counts = df['annee'].value_counts().sort_index()
        fig = px.bar(x=year_counts.index, y=year_counts.values, 
                    title="Nombre d'enregistrements par ann√©e")
        st.plotly_chart(fig, use_container_width=True)

def show_analysis(df):
    """Analyse exploratoire de vos donn√©es"""
    st.header("üîç Analyse Exploratoire - Vos Donn√©es MySQL")
    
    if df.empty:
        st.warning("Aucune donn√©e √† analyser")
        return
    
    # Informations g√©n√©rales
    st.subheader("üìä Informations sur vos donn√©es")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**Colonnes disponibles:**")
        for col in df.columns:
            st.write(f"- {col} ({df[col].dtype})")
    
    with col2:
        st.write("**Statistiques descriptives:**")
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        if len(numeric_cols) > 0:
            st.dataframe(df[numeric_cols].describe())
        else:
            st.write("Aucune colonne num√©rique d√©tect√©e")
    
    # Analyse par d√©partement si disponible
    if 'departement' in df.columns:
        st.subheader("üèõÔ∏è Analyse par d√©partement")
        dept_counts = df['departement'].value_counts()
        fig = px.bar(x=dept_counts.values, y=dept_counts.index, 
                    orientation='h', title="Enregistrements par d√©partement")
        st.plotly_chart(fig, use_container_width=True)

def show_visualizations(df):
    """Visualisations de vos donn√©es"""
    st.header("üìà Visualisations - Donn√©es MySQL")
    
    if df.empty:
        st.warning("Aucune donn√©e √† visualiser")
        return
    
    # S√©lection des colonnes √† visualiser
    numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
    categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
    
    if len(numeric_cols) > 0:
        st.subheader("üìä Visualisations num√©riques")
        selected_num_col = st.selectbox("Choisissez une colonne num√©rique", numeric_cols)
        
        if selected_num_col:
            fig = px.histogram(df, x=selected_num_col, title=f"Distribution de {selected_num_col}")
            st.plotly_chart(fig, use_container_width=True)
    
    if len(categorical_cols) > 0:
        st.subheader("üé≠ Visualisations cat√©gorielles")
        selected_cat_col = st.selectbox("Choisissez une colonne cat√©gorielle", categorical_cols)
        
        if selected_cat_col:
            value_counts = df[selected_cat_col].value_counts().head(20)
            fig = px.bar(x=value_counts.values, y=value_counts.index,
                        orientation='h', title=f"Top 20 - {selected_cat_col}")
            st.plotly_chart(fig, use_container_width=True)

def show_ml_results(df_processed, processor):  # ‚Üê Ajout des param√®tres
    st.header("ü§ñ Machine Learning")
    st.info("Section ML - En cours de d√©veloppement pour vos donn√©es sp√©cifiques")
    
    # Afficher d'abord les infos sur les donn√©es charg√©es
    if df_processed is not None:
        st.success(f"‚úÖ Donn√©es charg√©es : {len(df_processed)} enregistrements")
        
        # Informations sur les donn√©es
        col1, col2 = st.columns(2)
        with col1:
            st.metric("üìä Total enregistrements", len(df_processed))
            if 'famille_politique' in df_processed.columns:
                st.metric("üë• Familles politiques", df_processed['famille_politique'].nunique())
        
        with col2:
            if 'annee' in df_processed.columns:
                years = df_processed['annee'].unique()
                st.metric("üìÖ Ann√©es analys√©es", f"{min(years)}-{max(years)}")
            if 'departement' in df_processed.columns:
                st.metric("üó∫Ô∏è D√©partements", df_processed['departement'].nunique())
    
    # Charger les m√©tadonn√©es des mod√®les ML
    try:
        from pathlib import Path
        import joblib
        
        models_dir = Path("models")
        metadata_file = models_dir / "metadata.joblib"
        
        if metadata_file.exists():
            metadata = joblib.load(metadata_file)
            
            st.success("ü§ñ Mod√®les ML trouv√©s et charg√©s")
            
            # Afficher les performances
            st.subheader("üìä Performances des Mod√®les")
            
            results = metadata.get('last_results', {})
            
            if results:
                # Cr√©er un DataFrame pour afficher les r√©sultats
                import pandas as pd
                
                perf_data = []
                for model_name, result in results.items():
                    if 'accuracy' in result:
                        perf_data.append({
                            'Mod√®le': model_name,
                            'Accuracy': f"{result['accuracy']:.1%}",  # Format pourcentage
                            'Donn√©es Train': result.get('n_train', 'N/A'),
                            'Donn√©es Test': result.get('n_test', 'N/A'),
                            'Features': result.get('n_features', 'N/A')
                        })
                
                if perf_data:
                    df_perf = pd.DataFrame(perf_data)
                    st.dataframe(df_perf, use_container_width=True)
                    
                    # Meilleur mod√®le
                    best_model = metadata.get('best_model_name')
                    best_score = metadata.get('best_score', 0)
                    
                    st.success(f"üèÜ **Meilleur mod√®le** : {best_model}")
                    st.metric("Accuracy du meilleur mod√®le", f"{best_score:.1%}")
                    
                    # Graphique de comparaison
                    if len(perf_data) > 1:
                        st.subheader("üìà Comparaison des Mod√®les")
                        
                        # Pr√©parer les donn√©es pour le graphique
                        chart_data = pd.DataFrame({
                            'Mod√®le': [item['Mod√®le'] for item in perf_data],
                            'Accuracy': [float(item['Accuracy'].rstrip('%'))/100 for item in perf_data]
                        })
                        
                        import plotly.express as px
                        fig = px.bar(
                            chart_data, 
                            x='Mod√®le', 
                            y='Accuracy',
                            title='Comparaison des Performances',
                            color='Accuracy',
                            color_continuous_scale='viridis'
                        )
                        fig.update_layout(yaxis_tickformat='.1%')
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Informations suppl√©mentaires
                    st.subheader("‚ÑπÔ∏è Informations Techniques")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.info("**Configuration des Mod√®les**")
                        st.write("üå≥ **RandomForest**")
                        st.write("‚Ä¢ 100 arbres de d√©cision")
                        st.write("‚Ä¢ Profondeur max : 10")
                        st.write("‚Ä¢ Parall√©lisation activ√©e")
                        st.write("")
                        st.write("üìä **Logistic Regression**") 
                        st.write("‚Ä¢ R√©gularisation L2")
                        st.write("‚Ä¢ Normalisation des donn√©es")
                        st.write("‚Ä¢ 1000 it√©rations max")
                    
                    with col2:
                        st.info("**Variables d'Analyse**")
                        st.write("‚Ä¢ **Temporelles** : ann√©e, d√©cennie")
                        st.write("‚Ä¢ **G√©ographiques** : d√©partement, urbain/rural")
                        st.write("‚Ä¢ **√âlectorales** : participation, voix")
                        st.write("‚Ä¢ **D√©riv√©es** : influence, tendances")
                        st.write("")
                        st.write("‚Ä¢ **Classes** : 6 familles politiques")
                        st.write("‚Ä¢ **P√©riode** : 1993-2022 (30 ans)")
            else:
                st.warning("Aucun r√©sultat de performance trouv√©")
        else:
            st.warning("‚ö†Ô∏è Aucun mod√®le ML trouv√©")
            st.info("Lancez d'abord : `python main.py --predict`")
            
            # Bouton pour lancer l'entra√Ænement
            if st.button("üöÄ Lancer l'entra√Ænement ML"):
                st.info("Commande √† ex√©cuter : `python main.py --predict`")
            
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des mod√®les : {e}")
        
        # Affichage de fallback avec les donn√©es disponibles
        if df_processed is not None:
            st.info("üìä **Analyse des donn√©es disponibles**")
            
            # Analyse rapide des donn√©es
            if 'famille_politique' in df_processed.columns:
                st.subheader("Distribution des Familles Politiques")
                famille_counts = df_processed['famille_politique'].value_counts()
                
                import plotly.express as px
                fig = px.pie(
                    values=famille_counts.values, 
                    names=famille_counts.index,
                    title="R√©partition des Familles Politiques"
                )
                st.plotly_chart(fig, use_container_width=True)
        
        st.info("Cette section sera compl√®te apr√®s l'entra√Ænement des mod√®les.")

def show_predictions(df_processed, processor):
    st.header("üîÆ Pr√©dictions √âlectorales R√©elles")
    st.info("üéØ **Pr√©dictions bas√©es sur vos donn√©es MySQL avec vraies nuances politiques**")
    
    # Charger le vrai pr√©dicteur
    try:
        from src.prediction.real_prediction import RealElectionPredictor
        if df_processed is not None and 'nuance' in df_processed.columns:
            nuances_disponibles = df_processed['nuance'].unique().tolist()
            nuances_disponibles = [n for n in nuances_disponibles if n is not None and str(n).strip()]
            predictor = RealElectionPredictor(nuances_list=nuances_disponibles)
            
            st.info(f"üé≠ **Nuances de votre BDD** : {', '.join(nuances_disponibles)}")
        else:
            predictor = RealElectionPredictor()
            st.warning("‚ö†Ô∏è Colonne 'nuance' non trouv√©e, utilisation des valeurs par d√©faut")
    
        model_info = predictor.get_model_info()
        
        # Afficher les informations du mod√®le
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("ü§ñ Mod√®le", model_info['model_name'])
        with col2:
            st.metric("üéØ Accuracy", f"{model_info['accuracy']:.1%}")
        with col3:
            st.metric("üìä Donn√©es", f"{model_info['data_points']:,}")
        with col4:
            st.metric("üîå MySQL", model_info['mysql_status'])
        
        st.success("‚úÖ Pr√©dicteur charg√© avec vos donn√©es MySQL")
        
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement : {e}")
        st.info("V√©rifiez que Laragon est d√©marr√© et que le fichier real_predictor.py existe")
        return
    
    # Interface de pr√©diction
    st.subheader("üéØ Simulateur de Pr√©diction")
    
    with st.form("prediction_form"):
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**‚è∞ Param√®tres Temporels**")
            annee = st.selectbox("Ann√©e d'√©lection", [2025, 2027, 2030, 2032], index=0)
            tour = st.selectbox("Tour", [1, 2], index=0)
            
            st.write("**üó∫Ô∏è Localisation**")
            # D√©partements selon vos vraies donn√©es
            departements_real = {
                "09 - Ari√®ge": 9,
                "11 - Aude": 11,
                "12 - Aveyron": 12, 
                "30 - Gard": 30,
                "31 - Haute-Garonne": 31,
                "32 - Gers": 32,
                "34 - H√©rault": 34,
                "46 - Lot": 46,
                "48 - Loz√®re": 48,
                "65 - Hautes-Pyr√©n√©es": 65,
                "66 - Pyr√©n√©es-Orientales": 66,
                "81 - Tarn": 81,
                "82 - Tarn-et-Garonne": 82
            }
            dept_name = st.selectbox("D√©partement", list(departements_real.keys()))
            departement = departements_real[dept_name]
            
            typologie = st.selectbox("Typologie", ["Urbaine", "Rurale"])
            
            # R√©gion historique
            midi_pyrenees_depts = [9, 12, 31, 32, 46, 65, 81, 82]
            if departement in midi_pyrenees_depts:
                region = st.selectbox("Ancienne r√©gion", 
                                     ["Midi-Pyr√©n√©es"], index=0)
            else:
                region = st.selectbox("Ancienne r√©gion", 
                                     ["Languedoc-Roussillon"], index=0)
        
        with col2:
            st.write("**üó≥Ô∏è Param√®tres √âlectoraux**")
            
            # Suggestions bas√©es sur vos donn√©es historiques
            if departement in [31, 34]:  # Toulouse, Montpellier
                default_inscrits = 45000
                default_participation = 68.5
            elif departement in [48, 9]:  # Loz√®re, Ari√®ge
                default_inscrits = 8000
                default_participation = 72.0
            else:
                default_inscrits = 25000
                default_participation = 65.0
            
            inscrits = st.number_input("Nombre d'inscrits", 
                                     min_value=1000, max_value=100000, 
                                     value=default_inscrits, step=500)
            
            taux_participation = st.slider("Taux de participation (%)", 
                                          35.0, 90.0, default_participation, step=0.5)
            
            # Calculs automatiques
            votants = int(inscrits * taux_participation / 100)
            abstentions = inscrits - votants
            
            st.write("**üìä Calculs Automatiques**")
            st.metric("Votants estim√©s", f"{votants:,}")
            st.metric("Abstentions", f"{abstentions:,}")
            st.metric("Taux d'abstention", f"{100-taux_participation:.1f}%")
        
        predict_button = st.form_submit_button("üöÄ Lancer la Pr√©diction", 
                                              use_container_width=True)
        
        if predict_button:
            st.markdown("---")
            
            # Pr√©parer les donn√©es pour la pr√©diction
            election_data = {
                'annee': annee,
                'departement': departement,
                'tour': tour,
                'inscrits': inscrits,
                'taux_participation': taux_participation,
                'typologie': typologie,
                'region': region
            }
            
            # Afficher les param√®tres (CORRECTION pour √©viter l'erreur de s√©rialisation)
            st.subheader("üìã Param√®tres de Pr√©diction")
            params_df = pd.DataFrame({
                'Param√®tre': [
                    'Ann√©e', 'Tour', 'D√©partement', 'Typologie', 'R√©gion',
                    'Inscrits', 'Participation', 'Votants'
                ],
                'Valeur': [
                    str(annee),                    # ‚Üê Convertir en string
                    str(tour),                     # ‚Üê Convertir en string
                    dept_name,                     # ‚Üê D√©j√† string
                    typologie,                     # ‚Üê D√©j√† string
                    region,                        # ‚Üê D√©j√† string
                    f"{inscrits:,}",              # ‚Üê D√©j√† string format√©
                    f"{taux_participation:.1f}%", # ‚Üê D√©j√† string format√©
                    f"{votants:,}"                # ‚Üê D√©j√† string format√©
                ]
            })
            st.dataframe(params_df, use_container_width=True)
            
            # Faire la pr√©diction R√âELLE
            st.subheader("üéØ R√©sultat de la Pr√©diction")
            
            with st.spinner("ü§ñ Analyse avec votre mod√®le entra√Æn√©..."):
                import time
                time.sleep(1.5)  # Simulation du temps de calcul
                
                # VRAIE PR√âDICTION bas√©e sur vos donn√©es
                predictions = predictor.predict_election(election_data)
                
                # R√©sultat principal
                if predictions and len(predictions) > 0:
                    winner = max(predictions.keys(), key=lambda k: predictions[k])
                    confidence = predictions[winner]
                    
                    # Affichage des r√©sultats
                    col1, col2 = st.columns([1, 2])
                    
                    with col1:
                        st.success(f"üèÜ **Pr√©diction Gagnante**")
                        st.metric(
                            label="Nuance Politique",
                            value=winner,
                            delta=f"{confidence:.1f}%"
                        )
                        
                        # Niveau de confiance
                        if confidence > 35:
                            st.success("‚úÖ Confiance √©lev√©e")
                        elif confidence > 25:
                            st.warning("‚ö†Ô∏è Confiance mod√©r√©e")
                        else:
                            st.info("üìä √âlection serr√©e")
                    
                    with col2:
                        # Graphique des r√©sultats
                        pred_df = pd.DataFrame(
                            list(predictions.items()),
                            columns=['Nuance Politique', 'Pourcentage']
                        ).sort_values('Pourcentage', ascending=True)
                        
                        import plotly.express as px
                        fig = px.bar(
                            pred_df, 
                            y='Nuance Politique',
                            x='Pourcentage',
                            title="Pr√©diction bas√©e sur vos donn√©es historiques MySQL",
                            color='Pourcentage',
                            color_continuous_scale='RdYlBu_r',
                            text='Pourcentage'
                        )
                        fig.update_traces(
                            texttemplate='%{text:.1f}%', 
                            textposition='outside'
                        )
                        fig.update_layout(
                            height=400,
                            showlegend=False,
                            xaxis_title="Pourcentage des votes (%)"
                        )
                        st.plotly_chart(fig, use_container_width=True)
                    
                    # Tableau d√©taill√©
                    st.subheader("üìä D√©tail des Pr√©dictions")
                    
                    # Calcul des voix estim√©es
                    voix_estimees = {}
                    total_voix = int(votants * 0.95)  # En excluant blancs/nuls
                    
                    for nuance, pourcentage in predictions.items():
                        voix_estimees[nuance] = int(total_voix * pourcentage / 100)
                    
                    detailed_df = pd.DataFrame([
                        {
                            'Nuance Politique': nuance,
                            'Pourcentage': f"{prob:.2f}%",
                            'Voix Estim√©es': f"{voix_estimees[nuance]:,}",
                            'Rang': idx + 1
                        }
                        for idx, (nuance, prob) in enumerate(
                            sorted(predictions.items(), key=lambda x: x[1], reverse=True)
                        )
                    ])
                    
                    st.dataframe(detailed_df, use_container_width=True)
                    
                    # Analyse contextuelle
                    st.subheader("üìà Analyse Contextuelle")
                    
                    analyse = []
                    
                    # Analyse d√©partementale
                    if departement in [31, 34]:
                        analyse.append("üèôÔ∏è **Effet urbain** : Grandes m√©tropoles, favorables aux nuances de gauche et centre")
                    elif departement in [9, 48]:
                        analyse.append("üèîÔ∏è **Effet montagnard** : Zones rurales avec tradition de droite")
                    elif departement in [30, 66]:
                        analyse.append("‚ö° **Zones RN** : D√©partements avec forte implantation RN historique")
                    
                    # Analyse temporelle
                    if annee >= 2025:
                        analyse.append("‚è∞ **Projection future** : Bas√©e sur les tendances MySQL 2012-2022")
                    
                    # Analyse participation
                    if taux_participation > 70:
                        analyse.append("üìà **Forte participation** : Tend √† mod√©rer les votes protestataires")
                    elif taux_participation < 55:
                        analyse.append("üìâ **Faible participation** : Peut renforcer RN et extr√™mes")
                    
                    for point in analyse:
                        st.info(point)
                    
                    # Note m√©thodologique
                    st.info(f"""
                    üìù **M√©thodologie**
                    - **Source** : {model_info['data_points']:,} r√©sultats de votre base MySQL ({model_info['years_covered']})
                    - **Nuances analys√©es** : Bas√©es sur vos vraies donn√©es historiques d'Occitanie
                    - **Algorithme** : {model_info['model_name']} (Accuracy: {model_info['accuracy']:.1%})
                    - **Variables** : Temporelles, g√©ographiques, √©lectorales, contextuelles
                    - ‚ö†Ô∏è **Avertissement** : Pr√©diction indicative bas√©e sur les tendances historiques
                    """)
                
                else:
                    st.error("‚ùå Aucune pr√©diction g√©n√©r√©e")
                    st.info("V√©rifiez la connexion MySQL et les donn√©es historiques")

def show_historical_validation(df_processed, processor):
    import streamlit as st
    import pandas as pd
    import plotly.express as px

    st.header("üîç Validation Historique des Pr√©dictions")
    st.info("üéØ **Testez la fiabilit√© de votre mod√®le sur les ann√©es pass√©es**")

    if df_processed is None or df_processed.empty:
        st.error("‚ùå Aucune donn√©e disponible pour la validation")
        return

    numerics = ['annee', 'tour', 'departement', 'inscrits', 'votants', 'abstentions', 'exprimes', 'voix']
    for col in numerics:
        if col in df_processed.columns:
            df_processed[col] = pd.to_numeric(df_processed[col], errors="coerce").astype("Int64")

    # Charger le pr√©dicteur
    try:
        from src.prediction.real_prediction import RealElectionPredictor
        predictor = RealElectionPredictor()
        model_info = predictor.get_model_info()
        st.success(f"‚úÖ Mod√®le charg√© : {model_info['model_name']} (Accuracy: {model_info['accuracy']:.1%})")
    except Exception as e:
        st.error(f"‚ùå Erreur chargement pr√©dicteur : {e}")
        return

    st.subheader("‚öôÔ∏è Param√®tres de Validation")
    col1, col2 = st.columns(2)

    with col1:
        if 'annee' in df_processed.columns:
            annees_disponibles = sorted(df_processed['annee'].dropna().unique(), reverse=True)
            annee_test = st.selectbox(
                "üìÖ Ann√©e √† tester",
                annees_disponibles,
                help="S√©lectionnez une ann√©e pr√©sente dans votre BDD pour la validation"
            )
        else:
            st.error("Colonne 'annee' non trouv√©e dans les donn√©es")
            return

        all_depts = [
            (9, "09 - Ari√®ge"),
            (11, "11 - Aude"),
            (12, "12 - Aveyron"),
            (30, "30 - Gard"),
            (31, "31 - Haute-Garonne"),
            (32, "32 - Gers"),
            (34, "34 - H√©rault"),
            (46, "46 - Lot"),
            (48, "48 - Loz√®re"),
            (65, "65 - Hautes-Pyr√©n√©es"),
            (66, "66 - Pyr√©n√©es-Orientales"),
            (81, "81 - Tarn"),
            (82, "82 - Tarn-et-Garonne"),
        ]
        dept_options = [f"{label} ({code})" for code, label in all_depts]
        dept_options.sort()
        dept_selected = st.selectbox("üó∫Ô∏è D√©partement √† tester", dept_options)
        departement_code = int(dept_selected.split('(')[1].split(')')[0])

    with col2:
        if 'tour' in df_processed.columns:
            tours_disponibles = sorted(df_processed[df_processed['annee'] == annee_test]['tour'].dropna().unique())
            tour_test = st.selectbox("üó≥Ô∏è Tour", tours_disponibles)
        else:
            tour_test = 1
            st.info("Colonne 'tour' non trouv√©e, utilisation du tour 1")

        show_details = st.checkbox("üìä Afficher les d√©tails", value=True)
        show_charts = st.checkbox("üìà Afficher les graphiques", value=True)

    annee_test = int(annee_test)
    departement_code = int(departement_code)
    tour_test = int(tour_test)

    if st.button("üöÄ Lancer la Validation", use_container_width=True):
        st.markdown("---")

        vraies_donnees = df_processed[
            (df_processed['annee'] == annee_test) &
            (df_processed['departement'] == departement_code) &
            (df_processed['tour'] == tour_test)
        ].copy()

        if vraies_donnees.empty:
            st.error(f"‚ùå Aucune donn√©e trouv√©e pour {annee_test}, d√©partement {departement_code}, tour {tour_test}")
            return

        st.success(f"‚úÖ {len(vraies_donnees)} enregistrements trouv√©s pour la validation")

        sample_row = vraies_donnees.iloc[0]
        midi_pyrenees_depts = [9,12,31,32,46,65,81,82]
        region = 'Midi-Pyr√©n√©es' if departement_code in midi_pyrenees_depts else 'Languedoc-Roussillon'
        typologie = 'Urbaine' if departement_code in [31, 34] else 'Rurale'
        election_data = {
            'annee': annee_test,
            'departement': departement_code,
            'tour': tour_test,
            'inscrits': int(sample_row.get('inscrits', 25000)),
            'taux_participation': float(sample_row.get('taux_participation', 65.0)) if 'taux_participation' in sample_row else 65.0,
            'typologie': typologie,
            'region': region
        }

        st.subheader("ü§ñ Pr√©diction vs R√©alit√©")
        with st.spinner("üîÑ G√©n√©ration des pr√©dictions..."):
            predictions = predictor.predict_election(election_data)

        if 'nuance' in vraies_donnees.columns and 'voix' in vraies_donnees.columns:
            total_voix = vraies_donnees['voix'].sum()
            vraies_resultats = {}
            for _, row in vraies_donnees.iterrows():
                nuance = row['nuance']
                voix = row['voix']
                pourcentage = (voix / total_voix) * 100 if total_voix > 0 else 0
                vraies_resultats[nuance] = vraies_resultats.get(nuance, 0) + pourcentage
        else:
            st.error("‚ùå Colonnes 'nuance' ou 'voix' non trouv√©es dans les donn√©es")
            return

        if predictions and vraies_resultats:
            st.subheader("üìä R√©sultats de la Validation")
            toutes_nuances = set(predictions.keys()) | set(vraies_resultats.keys())
            comparaison_data = []
            for nuance in toutes_nuances:
                pred_val = predictions.get(nuance, 0)
                vrai_val = vraies_resultats.get(nuance, 0)
                ecart = abs(pred_val - vrai_val)
                comparaison_data.append({
                    'Nuance': nuance,
                    'Pr√©diction (%)': round(pred_val, 2),
                    'R√©alit√© (%)': round(vrai_val, 2),
                    '√âcart (%)': round(ecart, 2),
                    '√âcart Relatif': f"{(ecart/max(vrai_val, 0.1)*100):.1f}%" if vrai_val > 0 else "N/A"
                })
            df_comparaison = pd.DataFrame(comparaison_data).sort_values('R√©alit√© (%)', ascending=False)

            col1, col2, col3, col4 = st.columns(4)
            with col1:
                ecart_moyen = df_comparaison['√âcart (%)'].mean()
                st.metric("üìä √âcart Moyen", f"{ecart_moyen:.2f}%")
            with col2:
                ecart_max = df_comparaison['√âcart (%)'].max()
                st.metric("üìà √âcart Maximum", f"{ecart_max:.2f}%")
            with col3:
                pred_gagnant = max(predictions.keys(), key=lambda k: predictions[k])
                vrai_gagnant = max(vraies_resultats.keys(), key=lambda k: vraies_resultats[k])
                gagnant_correct = pred_gagnant == vrai_gagnant
                st.metric("üèÜ Gagnant Pr√©dit", "‚úÖ Correct" if gagnant_correct else "‚ùå Incorrect")
            with col4:
                score_precision = 100 - min(ecart_moyen * 2, 100)
                st.metric("üéØ Score Pr√©cision", f"{score_precision:.1f}%")

            if show_details:
                st.subheader("üìã Comparaison D√©taill√©e")
                def color_ecart(val):
                    if isinstance(val, (int, float)):
                        if val < 2:
                            return 'background-color: #d4edda'
                        elif val < 5:
                            return 'background-color: #fff3cd'
                        else:
                            return 'background-color: #f8d7da'
                    return ''
                styled_df = df_comparaison.style.applymap(color_ecart, subset=['√âcart (%)'])
                st.dataframe(styled_df, use_container_width=True)

            if show_charts:
                st.subheader("üìà Visualisations Comparatives")
                col1, col2 = st.columns(2)
                with col1:
                    fig_bar = px.bar(
                        df_comparaison,
                        x='Nuance',
                        y=['Pr√©diction (%)', 'R√©alit√© (%)'],
                        title="Pr√©diction vs R√©alit√© par Nuance",
                        barmode='group',
                        color_discrete_sequence=['#ff7f0e', '#1f77b4']
                    )
                    fig_bar.update_xaxes(tickangle=45)
                    st.plotly_chart(fig_bar, use_container_width=True)
                with col2:
                    fig_scatter = px.scatter(
                        df_comparaison,
                        x='R√©alit√© (%)',
                        y='Pr√©diction (%)',
                        text='Nuance',
                        title="Corr√©lation Pr√©diction-R√©alit√©",
                        color='√âcart (%)',
                        color_continuous_scale='RdYlGn_r'
                    )
                    max_val = max(df_comparaison['R√©alit√© (%)'].max(), df_comparaison['Pr√©diction (%)'].max())
                    fig_scatter.add_shape(
                        type="line", line=dict(dash="dash"),
                        x0=0, x1=max_val, y0=0, y1=max_val
                    )
                    st.plotly_chart(fig_scatter, use_container_width=True)
                st.subheader("üìä Analyse des √âcarts")
                fig_ecarts = px.bar(
                    df_comparaison.sort_values('√âcart (%)', ascending=True),
                    x='√âcart (%)',
                    y='Nuance',
                    orientation='h',
                    title="√âcarts de Pr√©diction par Nuance",
                    color='√âcart (%)',
                    color_continuous_scale='RdYlGn_r'
                )
                st.plotly_chart(fig_ecarts, use_container_width=True)

            st.subheader("üìù Analyse des R√©sultats")
            analyse_points = []
            if gagnant_correct:
                analyse_points.append(f"‚úÖ **Gagnant correct** : Le mod√®le a correctement pr√©dit {pred_gagnant} comme gagnant")
            else:
                analyse_points.append(f"‚ùå **Gagnant incorrect** : Pr√©dit {pred_gagnant}, r√©el {vrai_gagnant}")
            if ecart_moyen < 3:
                analyse_points.append("üéØ **Pr√©cision excellente** : √âcart moyen < 3%")
            elif ecart_moyen < 5:
                analyse_points.append("üëç **Pr√©cision correcte** : √âcart moyen < 5%")
            else:
                analyse_points.append("‚ö†Ô∏è **Pr√©cision √† am√©liorer** : √âcart moyen > 5%")
            meilleure = df_comparaison.loc[df_comparaison['√âcart (%)'].idxmin()]
            pire = df_comparaison.loc[df_comparaison['√âcart (%)'].idxmax()]
            analyse_points.append(f"üèÖ **Meilleure pr√©diction** : {meilleure['Nuance']} (√©cart {meilleure['√âcart (%)']}%)")
            analyse_points.append(f"üìâ **Pr√©diction √† am√©liorer** : {pire['Nuance']} (√©cart {pire['√âcart (%)']}%)")
            for point in analyse_points:
                st.info(point)

            st.subheader("üí° Recommandations")
            recommandations = []
            if ecart_moyen > 5:
                recommandations.append("üîß Ajuster les param√®tres du mod√®le pour r√©duire l'√©cart moyen")
            if len([x for x in df_comparaison['√âcart (%)'] if x > 10]) > 0:
                recommandations.append("üìä Analyser les nuances avec de gros √©carts pour am√©liorer le mod√®le")
            if not gagnant_correct:
                recommandations.append("üéØ Revoir les variables les plus importantes pour la pr√©diction du gagnant")
            recommandations.append("üîÑ Tester sur d'autres ann√©es/d√©partements pour validation crois√©e")
            recommandations.append("üìà Comparer avec d'autres algorithmes (RandomForest, XGBoost, etc.)")
            for reco in recommandations:
                st.warning(reco)
        else:
            st.error("‚ùå Erreur lors de la g√©n√©ration des pr√©dictions ou du traitement des vraies donn√©es")

if __name__ == "__main__":
    main()